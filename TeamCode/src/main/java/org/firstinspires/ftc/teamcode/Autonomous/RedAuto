package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.pedropathing.follower.Follower;
import com.pedropathing.geometry.Pose;

import org.firstinspires.ftc.teamcode.pedroPathing.Constants;
import org.firstinspires.ftc.teamcode.subsystems.Intake;
import org.firstinspires.ftc.teamcode.subsystems.Transfer;
import org.firstinspires.ftc.teamcode.subsystems.SmartShooter;
import org.firstinspires.ftc.teamcode.subsystems.TurretTargeting;
import org.firstinspires.ftc.teamcode.subsystems.Indexer;

@Autonomous(name = "Red Path Auto", group = "Pedro Pathing")
public class RedAuto extends OpMode {

    private Follower follower;
    private RedPaths.Paths paths;
    private int step = 0;
    
    // Subsystems
    private Intake intake;
    private Transfer transfer;
    private SmartShooter shooter;
    private TurretTargeting targeting;
    private Indexer indexer;
    
    // Shooting state
    private boolean isShooting = false;
    private int ballsShot = 0;
    private long shootStartTime = 0;
    private static final long SHOOT_DELAY_MS = 500; // Time between balls
    private static final double INTAKE_POWER = 0.8;
    private static final double TRANSFER_POWER = 0.8;

    @Override
    public void init() {
        follower = Constants.createFollower(hardwareMap);

        // Match first pose in Basket1 (flipped coordinates)
        follower.setStartingPose(new Pose(56.000, 8.000));

        paths = new RedPaths.Paths(follower);
        
        // Initialize subsystems
        intake = new Intake(hardwareMap);
        transfer = new Transfer(hardwareMap);
        shooter = new SmartShooter(hardwareMap);
        targeting = new TurretTargeting(hardwareMap);
        indexer = new Indexer(hardwareMap);
        
        // Configure shooter for red alliance
        shooter.configureKinematics(0.3, 1.2, 45.0);
        shooter.configureCamera(0.25, 15.0);
        shooter.setFlywheelDiameter(0.1);
        
        telemetry.addData("Status", "Initialized");
        telemetry.update();
    }

    @Override
    public void start() {
        follower.followPath(paths.Basket1);
    }

    @Override
    public void loop() {
        follower.update();
        shooter.update();
        targeting.update();
        
        // Handle intake during "Collect" paths
        String currentPathName = getCurrentPathName();
        if (currentPathName != null && currentPathName.toLowerCase().contains("collect")) {
            intake.intake(INTAKE_POWER);
            transfer.transfer(TRANSFER_POWER);
            indexer.open();
        } else if (!isShooting) {
            intake.stop();
            transfer.stop();
            indexer.close();
        }
        
        // Handle shooting sequence
        if (isShooting) {
            handleShooting();
        } else if (follower.atParametricEnd()) {
            // Check if we just finished a path and need to shoot
            if (currentPathName != null && 
                (currentPathName.toLowerCase().contains("basket") || 
                 currentPathName.toLowerCase().contains("shoot"))) {
                startShooting();
            } else {
                // Move to next path
                advanceToNextPath();
            }
        }
        
        // Telemetry
        telemetry.addData("Step", step);
        telemetry.addData("Current Path", currentPathName);
        telemetry.addData("Shooting", isShooting);
        telemetry.addData("Balls Shot", ballsShot);
        telemetry.update();
    }
    
    private void startShooting() {
        isShooting = true;
        ballsShot = 0;
        shootStartTime = System.currentTimeMillis();
        
        // Aim at red basket and spin up shooter
        targeting.aimAtRedBasket();
        shooter.shootAtRedBasket();
        indexer.open();
    }
    
    private void handleShooting() {
        // Continue aiming and maintaining shooter velocity
        targeting.aimAtRedBasket();
        shooter.shootAtRedBasket();
        
        long currentTime = System.currentTimeMillis();
        long timeSinceStart = currentTime - shootStartTime;
        
        // Shoot balls with delay between each
        if (ballsShot < 3) {
            long ballDelay = ballsShot * SHOOT_DELAY_MS;
            if (timeSinceStart >= ballDelay) {
                // Feed ball into shooter
                transfer.transfer(TRANSFER_POWER);
                
                // Check if enough time has passed to count this ball as shot
                if (timeSinceStart >= ballDelay + 200) { // 200ms feed time
                    ballsShot++;
                    transfer.stop();
                }
            }
        } else {
            // All balls shot, stop shooting
            isShooting = false;
            shooter.stopShooter();
            transfer.stop();
            indexer.close();
            
            // Move to next path
            advanceToNextPath();
        }
    }
    
    private void advanceToNextPath() {
        step++;

        switch (step) {
            case 1:
                follower.followPath(paths.Collect1);
                break;
            case 2:
                follower.followPath(paths.Gate1);
                break;
            case 3:
                follower.followPath(paths.Basket2);
                break;
            case 4:
                follower.followPath(paths.Collect2);
                break;
            case 5:
                follower.followPath(paths.Basket3);
                break;
            case 6:
                follower.followPath(paths.Collect3);
                break;
            case 7:
                follower.followPath(paths.Shoot4);
                break;
            case 8:
                follower.followPath(paths.Park);
                break;
            default:
                // Stop when done
                stopAllSubsystems();
                follower.startTeleopDrive(true);
                follower.setTeleOpDrive(0, 0, 0, true);
                break;
        }
    }
    
    private String getCurrentPathName() {
        switch (step) {
            case 0: return "Basket1";
            case 1: return "Collect1";
            case 2: return "Gate1";
            case 3: return "Basket2";
            case 4: return "Collect2";
            case 5: return "Basket3";
            case 6: return "Collect3";
            case 7: return "Shoot4";
            case 8: return "Park";
            default: return null;
        }
    }
    
    private void stopAllSubsystems() {
        intake.stop();
        transfer.stop();
        shooter.stop();
        targeting.stop();
        indexer.close();
    }
    
    @Override
    public void stop() {
        stopAllSubsystems();
    }
}
